\documentclass[12pt]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsthm, amsmath, amssymb}
\usepackage{hyperref}
\usepackage{datetime}
\usepackage{cmap}
\usepackage{enumerate}
\usepackage{color}
\usepackage{picture}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}
\usetikzlibrary{positioning,shadows,arrows}

\usepackage{bold-extra}

\def\EPS{\varepsilon}
\def\SO{\Rightarrow}
\def\EQ{\Leftrightarrow}
\def\t{\texttt}

\usetheme{Warsaw}

\let\Tiny=\tiny
\useoutertheme{infolines}

\tikzset {
    fact/.style={rectangle, draw=none, rounded corners=1mm, fill=blue, drop shadow,
        text centered, anchor=north, text=white},
    new/.style={circle, draw=none, fill=orange, circular drop shadow,
        text centered, anchor=north, text=white},
    state/.style={circle, draw=none, fill=red, circular drop shadow,
        text centered, anchor=north, text=white},
    leaf/.style={rectangle, draw=black,
    minimum width=0.5em, minimum height=0.5em},
    cur/.style={circle, draw=none, fill=green, circular drop shadow,
        text centered, anchor=north, text=black},
    level distance=1.0cm, anchor=south
}

\begin{document}

\title{Архивация FASTQ файлов}

\author[]{
    Подгузов Никита Владимирович \\
    Кравченко Дмитрий Сергеевич \\
    Бойкий Дмитрий Игоревич \\ 
    \vspace{\baselineskip}
    \footnotesize Куратор: Пржибельский Андрей 
}
\institute[]{Санкт-Петербургский Академический университет}
\date{25 мая 2015 года}

\frame{\titlepage}

\begin{frame}{Постановка задачи}

    \begin{itemize}

        \item <1-> Задача: максимально сжать входной FASTQ-файл.
        
        \item <2-> Входной файл: биологические данные, набор <<k-меров>> --- маленьких фрагментов до 150 символов, кусочков генома. 

        \item <3-> При считывании биологами возможны ошибки.

    \end{itemize}

\end{frame}

\begin{frame}{Формат файла}

    \begin{itemize}

        \item <1-> Состоит из блоков данных

        \begin{block}{Блок данных}
    
            @EAS54{\_}6{\_}R1{\_}2{\_}1{\_}540{\_}792\\
            TTGGCAGGCCAAGGCCGATGGATCA\\
            + \\
            ;;;;;;;;;;;7;;;;;-;;;3;83 

        \end{block}
    
        \item <2-> Большой размер входного файла (10 Mb -- 100 Gb)

    \end{itemize}

\end{frame}

\begin{frame}{Пути решения}

    Два типа алгоритмов сжатия:
    
    \begin{enumerate}

        \item <1-> Словарный метод
        
        \item <2-> Метод энтропийного сжатия

    \end{enumerate}

\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = \textcolor{orange}{a}bacaba
\begin{center}

\begin{tikzpicture}[]
\node [cur] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$}	
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = \textcolor{green}{a}\textcolor{orange}{b}acaba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [cur] {$1$}	
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = \textcolor{blue}{ab}acaba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [new] {$4$}
			edge from parent node[left] {$b$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
\textcolor{red}{1}
\end{block}

\end{center}
\end{frame}


\begin{frame}[fragile]{Алгоритм LZW}
s = a\textcolor{green}{b}\textcolor{orange}{a}caba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			edge from parent node[left] {$b$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [cur] {$2$}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = a\textcolor{blue}{ba}caba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			edge from parent node[left] {$b$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [new] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 \textcolor{red}{2}
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = ab\textcolor{green}{a}\textcolor{orange}{c}aba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [cur] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			edge from parent node[left] {$b$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = ab\textcolor{blue}{ac}aba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			edge from parent node[left] {$b$}
		}
		child{node [new] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 \textcolor{red}{1}
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = aba\textcolor{green}{c}\textcolor{orange}{a}ba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			edge from parent node[left] {$b$}
		}
		child{node [state] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [cur] {$3$}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 1
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = aba\textcolor{blue}{ca}ba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			edge from parent node[left] {$b$}
		}
		child{node [state] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		child{node [new] {$7$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 1 \textcolor{red}{3}
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = abac\textcolor{green}{a}\textcolor{orange}{b}a
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [cur] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			edge from parent node[left] {$b$}
		}
		child{node [state] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		child{node [state] {$7$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 1 3
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = abac\textcolor{green}{ab}\textcolor{orange}{a}
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [cur] {$4$}
			edge from parent node[left] {$b$}
		}
		child{node [state] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		child{node [state] {$7$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 1 3
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = abac\textcolor{blue}{aba}
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			child{node [new] {$8$}
				edge from parent node[left] {$a$}
			}
			edge from parent node[left] {$b$}
		}
		child{node [state] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		child{node [state] {$7$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 1 3 \textcolor{red}{4}
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = abacab\textcolor{green}{a}
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [cur] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			child{node [state] {$8$}
				edge from parent node[left] {$a$}
			}
			edge from parent node[left] {$b$}
		}
		child{node [state] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		child{node [state] {$7$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 1 3 4
\end{block}

\end{center}
\end{frame}

\begin{frame}[fragile]{Алгоритм LZW}
s = abacaba
\begin{center}
\begin{tikzpicture}[]
\node [state] {$Root$} [->] [sibling distance=3cm]
	child {node [state] {$1$} [sibling distance=1cm]
		child{node [state] {$4$}
			child{node [state] {$8$}
				edge from parent node[left] {$a$}
			}
			edge from parent node[left] {$b$}
		}
		child{node [state] {$6$}
			edge from parent node[left] {$c$}
		}
		edge from parent node[left] {$a$}
    }
    child {node [state] {$2$}
		child{node [state] {$5$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$b$}
    }
    child {node [state] {$3$}
		child{node [state] {$7$}
			edge from parent node[left] {$a$}
		}
		edge from parent node[left] {$c$}
    }
;
\end{tikzpicture}

\begin{block}{вывод}
1 2 1 3 4 \textcolor{red}{1}
\end{block}

\end{center}
\end{frame}


\begin{frame}{Алгоритм LZW}

    Проблема: из-за большого объема данных надо чистить бор \\

    Способы:

    \begin{enumerate}

        \item <1-> Оставить бор неизменяемым, как только заполнится первый раз

        \item <2-> Полное очищение бора при его заполнении

        \item <3-> std::set, в котором хранятся встречаемости вершин.
        
        \item <4-> Очищение какой-то части бора (например, $50\%$) при его
        заполнении

        \item <5-> Каждое константное количество шагов очищать бор на 
        константное количество вершин

    \end{enumerate}
    
\end{frame}


\begin{frame}{Алгоритм Хаффмана}

    \begin{itemize}

        \item Тип: частотный
        
        \item Алгоритм
        
        \begin{itemize}

            \item <1-> Подсчёт встречаемости каждого символа

            \item <2-> Построение дерева

            \item <3-> Сопоставление символов и кодов

        \end{itemize}

        \item Здесь будет картинка с деревом Хаффмана для простой строчки  

    \end{itemize}

\end{frame}

\begin{frame}{Оптимизации}

    \begin{itemize}

        \item <1-> Разделение файла на 4 части

        \item <2-> Применение разных алгоритмов к разным частям 

        \item <3-> Удаление ненужных веток в боре (алгоритм LZW)

        \item <4-> ??? (кодирование разностей между Quality, что-то еще?)
    
    \end{itemize} 

\end{frame}

\begin{frame}{Технические подробности}

    \begin{itemize}
    
        \item <1-> Проект написан на C++ (Google C++ Style Guide)

        \item <2-> Для удобства работы в команде использовался git

        \item <3-> Тестирование

        \begin{itemize}

            \item Unit-тесты (или нет) 

            \item Тестирование на реальных данных (см. результаты ниже)
        
        \end{itemize}

    \end{itemize}

\end{frame}

\begin{frame}{Технические подробности}

    \begin{itemize}

        \item Класс-интерфейс \texttt{Archiver}, содержащий два метода:
        
        \begin{itemize}

            \item \textit{Compress(Reader*, Writer*)}

            \item \textit{Decompress(Reader*, Writer*)}

        \end{itemize}

        \item Классы-интерфейсы \texttt{Reader} и \texttt{Writer}, осуществляющие чтение и запись различных типов данных соответственно.  

        \item Такая реализация позволяет просто реализовывать и интегрировать в программу различные алгоритмы сжатия и эвристики.
    
    \end{itemize} 

\end{frame}

\begin{frame}{Проблемы, с которыми столкнулись}

    \begin{itemize}
    
        \item Большой размер исходного файла (<<дорогие>> операции чтения и записи на диск)
        
        \item ???

    \end{itemize}
    
     

\end{frame}

\begin{frame}{Результаты}
    
    Здесь будет табличка со сравнением коэффициентов сжатия и времени работы различных общеиспользуемых архиваторов и нашего (будем надеться, что наш всех сделает).

\end{frame}

\begin{frame}{Ссылки}

    https://github.com/SPbAU-BI1/FASTQ

\end{frame}

\begin{frame}{}

    Вопросы?

\end{frame}

\end{document}